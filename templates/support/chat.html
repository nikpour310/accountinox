{% extends 'base.html' %}
{% load seo_tags %}

{% block meta_title %}گفت‌وگوی پشتیبانی | {{ site_settings.site_name|default:'Accountinox' }}{% endblock %}
{% block meta_robots %}
<meta name="robots" content="noindex,nofollow">
{% endblock %}

{% block content %}
<div class="page-wrapper max-w-3xl">
  {% if ticket_action_message %}
    <div class="{{ ticket_action_message_class }} mb-6 reveal">{{ ticket_action_message }}</div>
  {% endif %}
  {% if request.GET.rated == '1' %}
    <div class="alert alert-success mb-6 reveal">امتیاز شما ثبت شد. متشکریم.</div>
  {% endif %}

  <div class="mb-6 flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between reveal">
    <div>
      <h1 class="section-title">گفت‌وگو با پشتیبانی</h1>
      {% if contact %}
        <p class="section-subtitle">{{ contact.name }} - {{ contact.phone }}</p>
      {% endif %}
      <div class="mt-2 flex flex-wrap items-center gap-2">
        <span class="chip text-xs {{ session.status_badge_class }}">{{ session.status_label }}</span>
        <span class="text-xs text-gray-400">آخرین بروزرسانی: {{ session.last_message_at|default:session.created_at|jdate:'Y/m/d H:i' }}</span>
      </div>
    </div>
    <div class="flex w-full flex-col gap-2 sm:w-auto sm:flex-row">
      {% if session_is_owner and not session_closed %}
        <form method="post" action="{% url 'support:user_close_session' session.id %}" onsubmit="return confirm('گفتگو بسته شود؟');">
          {% csrf_token %}
          <input type="hidden" name="next" value="{{ request.get_full_path }}">
          <button type="submit" class="btn btn-ghost btn-sm w-full sm:w-auto">بستن گفتگو</button>
        </form>
      {% elif session_is_owner and session_closed %}
        <form method="post" action="{% url 'support:user_reopen_session' session.id %}">
          {% csrf_token %}
          <input type="hidden" name="next" value="{{ request.get_full_path }}">
          <button type="submit" class="btn btn-primary btn-sm w-full sm:w-auto">بازگشایی گفتگو</button>
        </form>
      {% endif %}
      <a href="{% url 'support:chat' %}" class="btn btn-ghost btn-sm w-full sm:w-auto">ویرایش اطلاعات</a>
    </div>
  </div>

  <div class="card-elevated overflow-hidden reveal">
    <div id="messages" class="h-[60vh] overflow-y-auto bg-gray-50/60 p-4 sm:h-[30rem] sm:p-6 space-y-3">
      {% if messages %}
        {% for message in messages %}
          <div class="flex {% if message.is_from_user %}justify-end{% else %}justify-start{% endif %}" data-message-id="{{ message.id }}">
            <div class="max-w-[85%] sm:max-w-[70%]">
              <p class="mb-1 text-[11px] text-gray-400 {% if message.is_from_user %}text-left{% else %}text-right{% endif %}">
                {{ message.name }} - {{ message.created_at|date:'H:i' }}
              </p>
              <div class="rounded-2xl px-4 py-2.5 text-sm leading-relaxed break-words shadow-sm {% if message.is_from_user %}bg-primary-600 text-white rounded-br-sm{% else %}bg-white border border-gray-200 text-gray-900 rounded-bl-sm{% endif %}">
                {{ message.message }}
              </div>
            </div>
          </div>
        {% endfor %}
      {% else %}
        <div id="empty-message" class="py-16 text-center text-sm text-gray-400">هنوز پیامی ارسال نشده است.</div>
      {% endif %}
    </div>
    <p id="operator-typing-indicator" class="hidden px-4 py-2 text-xs text-amber-600 sm:px-6">اپراتور در حال نوشتن پاسخ است...</p>

    <div class="divider"></div>

    <div class="bg-white p-4 sm:p-5 space-y-3">
      {% if session_closed %}
        {% if session_rating %}
          <div class="alert alert-success">امتیاز ثبت‌شده: {{ session_rating.score }} از 5</div>
        {% elif can_rate %}
          <div class="alert alert-info">
            گفت‌وگو بسته شده است.
            <a class="font-semibold underline" href="{% url 'support:rate_session' session.id %}">ثبت امتیاز اپراتور</a>
          </div>
        {% else %}
          <div class="alert">این گفت‌وگو بسته شده است. برای شروع گفت‌وگوی جدید به صفحه پشتیبانی برگردید.</div>
        {% endif %}
        <a href="{% url 'support:chat' %}" class="btn btn-primary w-full sm:w-auto">شروع گفت‌وگوی جدید</a>
      {% else %}
        <form id="user-message-form" class="space-y-3">
          {% csrf_token %}
          <input id="session-id-input" type="hidden" name="session_id" value="{{ session.id }}">
          <label for="user-message-input" class="sr-only">پیام</label>
          <textarea
            id="user-message-input"
            name="message"
            rows="3"
            maxlength="500"
            class="form-input"
            placeholder="پیام خود را بنویسید..."
            required
          ></textarea>
          <div class="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
            <p class="text-xs text-gray-400">حداکثر 500 کاراکتر</p>
            <button type="submit" class="btn btn-primary w-full sm:w-auto">ارسال پیام</button>
          </div>
          <p id="chat-form-feedback" class="hidden text-xs text-red-600"></p>
        </form>
      {% endif %}
    </div>
  </div>
</div>
{% endblock %}

{% block extra_scripts %}
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const messagesDiv = document.getElementById('messages');
      const form = document.getElementById('user-message-form');
      if (!messagesDiv) {
        return;
      }

      const emptyMessage = document.getElementById('empty-message');
      const messageInput = document.getElementById('user-message-input');
      const sessionIdInput = document.getElementById('session-id-input');
      const feedbackEl = document.getElementById('chat-form-feedback');
      const operatorTypingIndicator = document.getElementById('operator-typing-indicator');
      const sessionClosed = {{ session_closed|yesno:"true,false" }};
      const typingUpdateUrl = '{% url "support:typing_update" %}';
      const typingStatusBaseUrl = '{% url "support:typing_status" %}';
      let currentSessionId = Number(sessionIdInput ? sessionIdInput.value : {{ session.id }});
      let isPolling = false;
      let typingResetTimer = null;
      let userTypingSent = false;
      let typingStatusInFlight = false;

      const getLastMessageId = function() {
        const messageElements = messagesDiv.querySelectorAll('[data-message-id]');
        if (!messageElements.length) {
          return 0;
        }
        return Number(messageElements[messageElements.length - 1].getAttribute('data-message-id') || 0);
      };

      let lastId = getLastMessageId();

      const scrollToBottom = function() {
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
      };
      scrollToBottom();

      const appendMessage = function(message) {
        if (emptyMessage) {
          emptyMessage.remove();
        }
        const wrapper = document.createElement('div');
        wrapper.className = `flex ${message.is_from_user ? 'justify-end' : 'justify-start'}`;
        wrapper.dataset.messageId = String(message.id);

        const bubbleWrap = document.createElement('div');
        bubbleWrap.className = 'max-w-[85%] sm:max-w-[70%]';

        const meta = document.createElement('p');
        meta.className = 'mb-1 text-[11px] text-gray-400';
        meta.style.textAlign = message.is_from_user ? 'left' : 'right';
        const formattedTime = new Date(message.created_at).toLocaleTimeString('fa-IR', {
          hour: '2-digit',
          minute: '2-digit',
        });
        meta.textContent = `${message.name || 'کاربر'} - ${formattedTime}`;

        const bubble = document.createElement('div');
        bubble.className = `rounded-2xl px-4 py-2.5 text-sm leading-relaxed break-words shadow-sm ${
          message.is_from_user
            ? 'bg-primary-600 text-white rounded-br-sm'
            : 'bg-white border border-gray-200 text-gray-900 rounded-bl-sm'
        }`;
        bubble.textContent = message.message || '';

        bubbleWrap.appendChild(meta);
        bubbleWrap.appendChild(bubble);
        wrapper.appendChild(bubbleWrap);
        messagesDiv.appendChild(wrapper);
        scrollToBottom();
      };

      const setOperatorTypingIndicator = function(isTyping) {
        if (!operatorTypingIndicator) {
          return;
        }
        operatorTypingIndicator.classList.toggle('hidden', !isTyping);
      };

      const updateUserTypingState = async function(isTyping, force) {
        if (!form || !sessionIdInput) {
          return;
        }
        const csrfInput = form.querySelector('input[name="csrfmiddlewaretoken"]');
        if (!csrfInput) {
          return;
        }
        if (!force && userTypingSent === Boolean(isTyping)) {
          return;
        }
        userTypingSent = Boolean(isTyping);
        try {
          const payload = new URLSearchParams();
          payload.append('session_id', String(currentSessionId));
          payload.append('is_typing', isTyping ? '1' : '0');
          await fetch(typingUpdateUrl, {
            method: 'POST',
            credentials: 'same-origin',
            headers: {
              'X-CSRFToken': csrfInput.value,
              'X-Requested-With': 'XMLHttpRequest',
            },
            body: payload,
          });
        } catch (_) {}
      };

      const refreshTypingStatus = async function() {
        if (!currentSessionId || typingStatusInFlight) {
          return;
        }
        typingStatusInFlight = true;
        try {
          const response = await fetch(`${typingStatusBaseUrl}?session_id=${currentSessionId}`, {
            credentials: 'same-origin',
          });
          if (!response.ok) {
            return;
          }
          const data = await response.json();
          setOperatorTypingIndicator(Boolean(data.operator_typing));
        } catch (_) {
        } finally {
          typingStatusInFlight = false;
        }
      };

      const pollMessages = async function() {
        if (sessionClosed) {
          return;
        }
        if (isPolling || !currentSessionId) {
          window.setTimeout(pollMessages, 2500);
          return;
        }
        isPolling = true;
        try {
          const response = await fetch(`/support/poll/?thread_id=${currentSessionId}&since=${lastId}&timeout=10`, {
            credentials: 'same-origin',
          });
          if (!response.ok) {
            throw new Error('poll failed');
          }
          const data = await response.json();
          if (Array.isArray(data.messages) && data.messages.length > 0) {
            data.messages.forEach(function(msg) {
              appendMessage(msg);
              lastId = Math.max(lastId, Number(msg.id || 0));
            });
          }
          await refreshTypingStatus();
        } catch (_) {
        } finally {
          isPolling = false;
          window.setTimeout(pollMessages, 2500);
        }
      };

      if (form && messageInput) {
        messageInput.addEventListener('input', function() {
          const hasText = Boolean((messageInput.value || '').trim());
          if (hasText) {
            updateUserTypingState(true, false);
            if (typingResetTimer) {
              window.clearTimeout(typingResetTimer);
            }
            typingResetTimer = window.setTimeout(function() {
              updateUserTypingState(false, false);
            }, 2800);
          } else {
            if (typingResetTimer) {
              window.clearTimeout(typingResetTimer);
              typingResetTimer = null;
            }
            updateUserTypingState(false, false);
          }
        });

        messageInput.addEventListener('blur', function() {
          if (typingResetTimer) {
            window.clearTimeout(typingResetTimer);
            typingResetTimer = null;
          }
          updateUserTypingState(false, true);
        });

        form.addEventListener('submit', async function(event) {
          event.preventDefault();
          const text = messageInput.value.trim();
          if (!text || !currentSessionId) {
            return;
          }
          if (typingResetTimer) {
            window.clearTimeout(typingResetTimer);
            typingResetTimer = null;
          }
          await updateUserTypingState(false, true);
          if (feedbackEl) {
            feedbackEl.classList.add('hidden');
            feedbackEl.textContent = '';
          }
          const submitButton = form.querySelector('button[type="submit"]');
          const originalButtonText = submitButton ? submitButton.textContent : '';
          if (submitButton) {
            submitButton.disabled = true;
            submitButton.textContent = 'در حال ارسال...';
          }
          try {
            const response = await fetch('{% url "support:send_message" %}', {
              method: 'POST',
              body: new FormData(form),
              credentials: 'same-origin',
            });
            const data = await response.json().catch(function() {
              return {};
            });
            if (!response.ok || !data.ok) {
              if (data && data.session_closed) {
                window.location.reload();
                return;
              }
              throw new Error(data.error || 'send failed');
            }

            if (data.session_id && Number(data.session_id) !== currentSessionId) {
              currentSessionId = Number(data.session_id);
              if (sessionIdInput) {
                sessionIdInput.value = String(currentSessionId);
              }
              lastId = 0;
              messagesDiv.innerHTML = '';
            }

            messageInput.value = '';
            window.setTimeout(pollMessages, 200);
          } catch (error) {
            if (feedbackEl) {
              feedbackEl.textContent = 'ارسال پیام انجام نشد. دوباره تلاش کنید.';
              if (error && String(error.message || '').toLowerCase().includes('forbidden')) {
                feedbackEl.textContent = 'دسترسی شما به این گفتگو محدود شده است.';
              }
              feedbackEl.classList.remove('hidden');
            }
          } finally {
            if (submitButton) {
              submitButton.disabled = false;
              submitButton.textContent = originalButtonText || 'ارسال پیام';
            }
            await updateUserTypingState(false, true);
          }
        });
      }

      if (!sessionClosed) {
        refreshTypingStatus();
        window.setInterval(refreshTypingStatus, 2500);
        window.setTimeout(pollMessages, 1200);
      }
    });
  </script>
{% endblock %}
